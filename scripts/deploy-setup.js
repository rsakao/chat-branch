#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// ES moduleでは__dirnameが利用できないため、代替手段を使用
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Check if DATABASE_URL contains postgresql or postgres
const databaseUrl = process.env.DATABASE_URL;
const isPostgreSQL = databaseUrl && (databaseUrl.includes('postgresql') || databaseUrl.includes('postgres'));

console.log('Database URL:', databaseUrl);
console.log('Using PostgreSQL:', isPostgreSQL);

if (isPostgreSQL) {
  // Use PostgreSQL schema
  const postgresSchemaPath = path.join(__dirname, '..', 'prisma', 'schema.postgresql.prisma');
  const defaultSchemaPath = path.join(__dirname, '..', 'prisma', 'schema.prisma');
  
  if (fs.existsSync(postgresSchemaPath)) {
    console.log('Switching to PostgreSQL schema...');
    const postgresSchema = fs.readFileSync(postgresSchemaPath, 'utf8');
    fs.writeFileSync(defaultSchemaPath, postgresSchema);
    console.log('Schema switched to PostgreSQL');
    
    // Create migrations directory and files for PostgreSQL
    const migrationsDir = path.join(__dirname, '..', 'prisma', 'migrations');
    const migrationDir = path.join(migrationsDir, '0001_initial');
    
    // Ensure directories exist
    if (!fs.existsSync(migrationsDir)) {
      fs.mkdirSync(migrationsDir, { recursive: true });
    }
    if (!fs.existsSync(migrationDir)) {
      fs.mkdirSync(migrationDir, { recursive: true });
    }
    
    // Create migration SQL
    const migrationSQL = `-- CreateTable
CREATE TABLE "conversations" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "conversations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "messages" (
    "id" TEXT NOT NULL,
    "conversationId" TEXT NOT NULL,
    "parentId" TEXT,
    "role" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "messages_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "messages_conversationId_idx" ON "messages"("conversationId");

-- CreateIndex
CREATE INDEX "messages_parentId_idx" ON "messages"("parentId");

-- AddForeignKey
ALTER TABLE "messages" ADD CONSTRAINT "messages_conversationId_fkey" FOREIGN KEY ("conversationId") REFERENCES "conversations"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "messages" ADD CONSTRAINT "messages_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "messages"("id") ON DELETE SET NULL ON UPDATE CASCADE;
`;
    
    // Write migration files
    fs.writeFileSync(path.join(migrationDir, 'migration.sql'), migrationSQL);
    
    const migrationLock = `# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
`;
    
    fs.writeFileSync(path.join(migrationsDir, 'migration_lock.toml'), migrationLock);
    
    console.log('Migration files created for PostgreSQL');
  } else {
    console.error('PostgreSQL schema file not found');
    process.exit(1);
  }
} else {
  console.log('Using SQLite schema (default)');
}

console.log('Deploy setup completed'); 